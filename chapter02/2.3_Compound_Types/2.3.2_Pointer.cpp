/**
 * 2.3.2 指针
 * @Author Bob
 * @Eamil 0haizhu0@gmail.com
 * @Date 2017/7/3
 */

#include <iostream>

int main() {
  /**
   * 指针是指向另外一种类型的符合类型。与引用相比，指针也实现了对其他对象的间接访问。
   * 然而指针与引用相比，又有很多不同点：
   * 1. 指针本身就是一个对象，允许对指针进行赋值和拷贝，而且可以先后指向不同的对象
   * 2. 指针无需再定义时赋初值。
   */

  /**
   * 指针值（即地址），应属于下列4种状态之一：
   * 1. 指向一个对象
   * 2. 指向紧邻对象所占空间的下一个位置
   * 3. 空指针，意味着指针没有指向任何对象
   * 4. 无效指针，也就是上述情况之外的其他值
   */

  int *ip1, *ip2; // ip1,ip2都是指向int型对象的指针
  double dp, *dp2; // dp2是指向double型对象的指针，dp是double型对象

  /**
   * 获取对象的地址：
   * 指针是存放某个对象的地址，想要获取该地址，需要使用取地址符（操作符&）
   * Bob：& 既是声明引用的标志，也是访问引用地址的方式
   */
  int ival = 42;
  int *p = &ival; // 定义指针p，指向ival对象

  /**
   * 利用指针访问对象，使用解引用符（操作符*）来访问该对象
   * Bob：* 既是声明指针的标志，也是访问指针值的方式
   */
  std::cout << "ival = " << ival << std::endl;   // 变量ival的值
  std::cout << "&ival = " << &ival << std::endl; // &是在已经声明并初始化的变量ival之前，所以是取地址符，打印出来的是ival的内存地址
  std::cout << "p = " << p << std::endl;         // p 是指针，直接打印是指针指向的对象的内存地址
  std::cout << "*p = " << *p << std::endl;       // *p 是解引用p指针，表示获取指针指向的对象的值
  std::cout << "&p = " << &p << std::endl;       // &位于声明并初始化的指针p之前，表示取地址，所以打印出来的是指针p的内存地址

  ival = 24;  // 更改ival的值，那么*p的值就发生了变化，因为指向的是同一个对象

  std::cout << "ival = " << ival << std::endl;
  std::cout << "*p = " << *p << std::endl;

  *p = 12;  // 更改*p的值，那么ival的值也同样发生了变化，因为指向的是同一个对象

  std::cout << "ival = " << ival << std::endl;
  std::cout << "*p = " << *p << std::endl;

  /**
   * 空指针，建议使用如下第一种方式，尽量避免使用后面两种方法
   */
  int *p1 = nullptr; // C++11 新标准，推荐使用此方式
  int *p2 = 0;    // 初始化为字面常量0
  int *p3 = NULL; // 预处理变量，它的值就是0，需要引入cstdlib

  /**
   * void* 指针，能存放任意类型对象的地址（更多内容参考19.1.1节）
   */
  double obj = 3.14, *pd = &obj;
  void *pv = &obj; // obj可以是任意类型的对象
  pv = pd; // pv可以存放任意类型的指针

  return 0;
}
